Постановка задачи
=================

В рамках практического задания требуется программно реализовать алгоритмы формирования ЭЦП и проверки ЭЦП для произвольного файла в соответствии со стандартом ГОСТ Р 34.10-94 или ГОСТ Р 34.10-2001. В данной работе реализован алгоритм, соответствующий стандарту ГОСТ Р 34.10-94 с использованием хеш-функции, соответствующей стандарту ГОСТ Р 34.11-94 с использованием реализации алгоритма режима простой замены в соответствии со стандартом ГОСТ 28147-89.

Описание алгоритмов
===================

Шифр простой замены
-------------------

Соответствие стандартам: ГОСТ 28147-89, режим простой замены.

Секретные параметры:

* Блоки подстановки заданы статически. Используются блоки подстановки, предлагаемые в примере из стандарта ГОСТ Р 34.11-94.
* 256-битный ключ передаётся параметром в процедуры шифрования и расшифрования.

Интерфейс описан в заголовочном файле "substitution.h". Состоит из двух функций, одна выполненяет шифрование, другая — расшифрование. Параметрами функций являются 256-битный ключ и 64-битное сообщение (исходное или зашифрованное соответственно). На выходе алгоритм возвращает зашифрованное или расшифрованное сообщение соответственно.

Хеш-функция
-----------

Соответствие стандартам: ГОСТ Р 34.11-94.

Секретные параметры:

* Блоки подстановки. См. «шифр простой замены».

Интерфейс описан в заголовочном файле "hash.h". Для хеширования необходимо создать переменную типа "hasher_state" и инициализировать её функцией "init_hasher". Затем для каждого блока входных данных необходимо вызвать функцию "make_hasher_step" с указанием реального размера блока в байтах (количества прочитанных из потока данных байт). Чтение и обработка блоков данных меньше байта не предусмотрена, поскольку байт является (по определению) минимальной адресуемой единицей памяти и входные данные не могут содержать дробное число байт.

Чтобы получить итоговое значение хеш-функции нужно вызвать функцию "get_hash".

ЭЦП
---

Соответствие стандартам: ГОСТ Р 34.10-94.

Секретные параметры:

* Блоки подстановки. См. «шифр простой замены».
* Параметры алгоритма p, q и a. Хранятся в переменной типа "signature_attr".
* Секретный ключ x. Хранится в той же переменной, что и параметры алгоритма.

Интерфейс описан в заголовочном файле "signature.h". В работе алгоритма используется структура для хранения аттрибутов и ключей "signature_attr". Заполнить её тестовыми значениями можно с помощью функций "gen_signature_attr" и "gen_keys_pair". После этого можно сгенерировать или проверить подпись функциями "make_signature" и "test_signature". Они принимают на вход параметры алгоритма и ключи (в переменной типа "signature_attr"). Первая функция использует секретный ключ (x), вторая — открытый (y). Тестовые параметры были взяты из RFC 4357 ввиду недоступности печатного экземпляра стандарта ГОСТ Р 34.10-94.

В данном учебном задании не предусмотрен интерфейс для управления ключами (генерация и запись ключей в пару файлов, чтение из файла закрытого ключа при создании подписи и открытого ключа при проверке подписи) и интерфейс для управления параметрами алгоритма ЭЦП (чтение, запись). Для реального использования данные интерфейсы необходимы.

Особенности программной реализации
==================================

В этом разделе описаны как достоинства реализации, так и недостатки.

Общие свойства реализации
-------------------------

Проект написан на переносимом подмножестве C99 и на системных вызовах и библиотечных функциях, соответствующих POSIX. В коде не используется никаких допущений о параметрах архитектуры, на которой будет выполняться приложение. От ОС требуется частичное соответствие POSIX.

Проект разбит на модули, каждый модуль выполняет строго определённую функцию. Например, модуль хеширования не использует никаких функций чтения. Если задача не выполняется в один шаг (как при шифровании блока данных в режиме простой замены), то закономерным следствием такого подхода является необходимость хранить состояние, относящееся к задаче, выполняемой модулем. Модули "ioutils", "hash" и "signature" хранят состояние задачи в переменных с типами "reader_state", "hasher_state" и "signature_attr" соответственно. Следует заметить, что это состояние не является глобальным и код модуля может, вообще говоря, выполнять несколько задач одновременно. К примеру, можно завести две переменных типа "hasher_state" и считать хеш-функции от двух вообще говоря различных потоков данных параллельно. При работе с модулями "reader_state" и "hasher_state" удобно рассматривать их в виде конечных автоматов (в случае автомата хеширования порождённый автоматом символ находится в поле "hash" структуры "hasher_state").

Интерфейс обмена числами фиксированной длины (u256_t) и числами произвольной длины (mpz_t) организован таким образом, чтобы избежать лишних копирований. Как правило, принимающие аргументы передаются первыми параметрами, затем входные параметры (можно провести аналогию с Intel-синтаксисом записи ассемблерных инструкций). Таким образом организован интерфейс библиотеки для работы с числами произвольной размерности gmp.

В приложении не используются в явном виде функции работы с динамической памятью (heap). Неявно эти функции могут использоваться библиотекой gmp. Стоит упомянуть, что новые области памяти приложение получает с помощью файловых отображений, но использует эти страницы только для чтения из файлов. Таким образом, архитектура приложения подразумевает возможность оптимизации скорости алгоритмов и ситуация, когда работа динамической памятью может стать «узким местом» алгоритма, исключается.

Для реального применения требуется оптимизация функции хеширования, чтобы приблизить скорость обработки данных к скорости их чтения с диска. В текущей реализации алгоритм хеширования преобразует данные значительно дольше, чем ждёт обмена (при использовании файловых отображений). Возможны как архитектурно-независимые оптимизации, так и архитектурно-зависимые.

Для проведения архитектурно-независимой оптимизации требуется исследование оптимизаций, проводимых компилятором.

Примерами возможных архитектурно-зависимых оптимизаций может служить написание ассемблерных вставкок под некоторое число распространённых архитектур и использование SIMD-инструкций современных процессоров. Следует отметить, что наличие архитектурно-зависимых оптимизаций не отменяет кроссплатформенности приложения в целом, т.к. подразумевает, что на архитектурах, под которые не были проделаны данные оптимизации будет работать кроссплатформенный код на C.

Процедуры ввода-вывода
----------------------

Интерфейс процедур ввода-вывода описан в заголовочном файле "ioutils.h". Программа предусматривает два способа чтения файлов — с помощью файловых отображений или с помощью системного вызова "read". Использование файловых отображений предпочтительней, так как позволяет избежать копирования данных из виртуального пространства ядра в виртуальное пространство пользователя, что существенно повышает скорость чтения больших файлов. В данном проекте скорость чтения файлов влияет на скорость скорость вычисления хеш-функции и, которая используется как для генерации подписи, так и для её проверки.

Выбор способа чтения файлов осуществляется на этапе компиляции с помощью ключа компилятора -DNO_MMAP (определяет соответствующий макрос во всех файлах исходного кода на этапе компиляции, точнее макропроцессирования).

Способ чтения файлов через файловые отображения подразумевает отображение блоков файлов, кратных размеру страницы виртуальной памяти, в адресное пространство пользователя с помощью системных вызовов "mmap" и "munmap". Количество отображаемых за один раз страниц памяти определяется во время компиляции и по умолчанию равно 128, что при обычном размере виртуальной странцы в 4 Kb соответствует 512 Kb данных.

Чтение данных через файловые отображения происходит достаточно быстро, чтобы не являться причиной существенных задержек в работе хеш-фукнции. Даже на медленном жёстком диске с поддержкой DMA данные читаются значительно быстрее, чем обрабатываются. Это, конечно, следствие недостаточно оптимального алгоритма вычисления хеш-функции, но, тем не менее, в текущей реализации чтение файла не является «узким местом».

Для случая ОС семейства Windows пришлось отказаться от использования файловых отображений в пользу чтения файла с помощью системного вызова "read". В Windows API существуют функции CreateFileMapping() и MapViewOfFile(), но успешность данных системных вызовов сильно зависит от работы других процессов в системе и, судя по всему, эти функции часто могут завершиться неудачно даже при достаточном количестве доступных системных ресурсов.

Вопрос с быстрым чтением больших файлов под Windows был исследован, но подходящего способа найдено не было. При работе с небольшими файлами (порядка нескольких десятков мебибайт) чтение с помощью системного вызова "read" уместно.

«Длинные» числа
---------------

Работа с беззнаковыми числами фиксированной длины 64 бита осуществляется с использованием стандартных типов "uint_fast32_t" и "uint_fast64_t", описываемых в заголовочном файле "stdint.h" и поддерживаемым любым компилятором, соответствующим стандарту языка программирования C99.

Работа с беззнаковыми числами фиксированной длины 256 бит реализована в модуле с заголовочным файлом "u256.h". В данном модуле определяется тип u256_t (фактически, массив из 4-х значений типа "uint_fast64_t") и функции для работы с ним. В частности:

* Преобразование 256-битного (32-байтного) числа к массиву байт, слов или двойных слов, сборка из массивов данного типа 256-битного числа.

* Присваивание, зануление, «исключающее или» (xor), сложение 256-битных чисел.

* Преобразование к числу произвольной длины типа mpz_t из библиотеки gmp ("The GNU Multiple Precision Arithmetic Library"). Tребуется для работы алгоритма цифровой подписи, не требуется для работы алгоритма шифрования в режиме простой замены и работы хеш-функции.

Иногда работа с типом u256_t производится непосредственно с помощью операций над составляющими его элементами типа "uint_fast64_t". В этом случае младший индекс элемента означает младшие разряды. Можно сказать, что qword или 64-битные числа, составляющие данное 256-битное, распологаются в массиве в little endian нотации, т.е. младший qword идёт первым. Обращение напрямую к элементам массива, скрытого за названием типа u256_t не нарушает принцип инкапсуляции, т.к. имеет конкретное и уместное значение.

Случайные числа
---------------

Для генерации псевдослучайных чисел в алгоритме, реализующем генерацию ЭЦП, использовался генератор псевдослучайных чисел (ГСЧ) из состава библиотеки gmp, реализованный по алгоритму, называемому «Вихрь Мерсенна» (Mersenne Twister algorithm). Зерно (seed) для ГСЧ задано статично, но для реального применения зерно должно генерироваться во время выполнения приложения с использованием 256 битов шума в пуле энтропии. Различные ОС предоставляют механизмы для получения зерна ГСЧ: устройство /dev/random под Linux и функция CryptGetRandom() из Windows API под Windows.

Среда программирования
----------------------

Gentoo Linux x86_64, vim 7.3.

Toolchain:

* gcc 4.7.2.
* glibc 2.16.0.
* GNU Binutils 2.23.1.

Cross compilation toolchain:

Аналогичен по версиям основному toolchain'у, но собран (для Gentoo Linux x86_64) с помощью утилиты crossdev для сборки под архитектуру i686-mingw32.

Сборка
------

Сборка под Linux:

$ make

Сборка под BSD:

$ gmake

Сборка под Windows (требует MinGW, возможна адаптация для Cygwin):

$ make -f Makefile.win

Использование
-------------

Программа ЭЦП реализуется как тестовый модуль "tests/signature_test". Справку по использованию можно получить с помощью команды

$ tests/signature_test --help

Вызов команды имеет два формы:

$ tests/signature_test make file file.sg
$ tests/signature_test test file file.sg

Первая команда выполняет генерацию ЭПЦ: первый файл открывается на чтение, второй на запись. Вторая команда выполняет проверку ЭЦП: оба файла открываются на чтение.

Результаты тестирования программы
=================================

Общие принципы тестирования
---------------------------

Большая часть модулей приложения имеет соответствующий модуль тестирования в директории "tests" (фактически, использована концепция unit-тестирования). Модули тестирования не реализуют конкретного покрытия функциональности соответствующего модуля приложения тестами, а представляют из себя сравнительно небольшие программы на C99, предоставляющими консольный интерфейс к функциям соответствующего модуля приложения.

Таким образом, имеем следующий набор программ для тестированя модулей:

* tests/ioutils_test[.exe]  — читает файл и выводит его содержимое на стандартный поток вывода.

* tests/substitution_test[.exe] - читает файл и выдаёт в зависимости от выбранного действия его зашифрованное или расшифрованное представление на стандартный поток вывода.

* tests/hash_test[.exe] — читает файл и выводит его хеш.

* tests/signature_test[.exe] — читает файл с данными и, в зависимости от выбранного действия, генерирует ЭЦП или проверяет её.

Первые два теста медленно работают с большими файлами из-за отсутствия мультиплексирования вывода (производится большое количество системных вызовов "write"). Если приложение предпологается использовать в для шифрования данных методом простой замены, то в модуль ioutils будет необходимо дописать реализацию мультиплексирования вывода и осуществлять вывод через соответствующий интерфейс.

Каждая из данных программ выдаёт краткую справку по аргментам командной строки, если запустить её с единственным ключём "--help", поэтому описание формата аргументов командной строки в данном отчёте считаю излишним.

Покрытие тестами
----------------

Корректность работы функций ввода и вывода проверяется непосредственной проверкой на нескольких файлах. При этом в Unix-системах может использовать перенаправление ввода-вывода и такие утилиты как cat и diff.

Корректность работы функций шифрования и расшифрования с помощью метода простой замены также проверяется непосредственно с помощью шифрования и расшифрования некоторого набора файлов. Соответствие стандарту ГОСТ 28147-89 подтверждается успешным прохождением теста хеш-функцией.

Корректность и соответствие стандарту ГОСТ Р 34.11-94 работы хеш-функции можно проверить на тестовых примерах с помощью команды

$ make hashtest

или с помощью эквивалентной последовательности команд

$ ./tests/hash_test tests/hashtest1.data && cat tests/hashtest1.hash
$ ./tests/hash_test tests/hashtest2.data && cat tests/hashtest2.hash

В указанных файлах содержатся примеры, предлагаемые стандартом ГОСТ Р 34.11-94 для проверки работы хеш-функции.

Корректной работы алгоритма ЭЦП проверяется непосредственно. Проверка на соответствие ГОСТ Р 34.10-94 была проведена вручную ввиду необходимости получения определённых значений псевдослучайных чисел. Тестирование внешними по отношению к исходному коду средствами требует некоторых усложнений, которые могут отразиться на читаемости алгоритма и простоте интерфейса. Для проверки работы алгоритма были использованы данные из RFC 4357 ввиду недоступности печатного экземпляра стандарта ГОСТ Р 34.10-94. Тест был пройден успешно.

Для модуля "u256" отсутствует модуль тестирования, но, поскольку его функциональность в полной мере используется другими модулями (главным образом, модулем, реализующем работу хеш-функции), для которых проверены корректность и соответствие стандартам, можно считать, что работа модуля "u256" корректна.

Кроссплатформенность
--------------------

Отдельно тестировалась неизменность работы приложения при работе на разных архитектурах и ОС. Тесты проводились с помощью:

* Gentoo Linux x86_64 с исполняемыми файлами ELF 64-bit.
* Wine 1.5.25 с исполняемыми файлами PE 32-bit.
* Windows XP SP2 гостевой системой VirtualBox 4.2.12 с исполняемыми файлами PE 32-bit.

В последних двух случаях основной (host) ОС выступал Gentoo Linux x86_64.

Различия в поведении заключаются только в том, что при выводе на стандартный поток вывода окончания строк приводятся к тому виду, который принят в ОС, на которой выполняется приложение. Под любым Unix строки оканчиваются символом LF, под Windows и Wine — CR+LF. Это следует иметь ввиду при работе с тестовыми модулями "ioutils_test" и "substitution_test".

Данный факт никак не влияет на вычисление хеш-функции, генерацию ЭЦП и проверку ЭЦП. Генерация ЭЦП может быть произведена на компьютере с одной архитектурой и ОС, а проверка ЭЦП на компьютере с другой архитектурой и/или ОС.

// vim: set ft=asciidoc:
